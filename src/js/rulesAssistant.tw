:: rulesAssistant [script]

// RAJS
/*
window.ruleApplied = function(slave, ID) {
	if (!slave || !slave.currentRules)
		return null;
	return slave.currentRules.includes(ID);
};

window.ruleSlaveSelected = function(slave, rule) {
	if (!slave || !rule || !rule.selectedSlaves)
		return false;
	return rule.selectedSlaves.includes(slave.ID);
};

window.ruleSlaveExcluded = function(slave, rule) {
	if (!slave || !rule || !rule.excludedSlaves)
		return false;
	return rule.excludedSlaves.includes(slave.ID);
};

window.ruleAssignmentSelected = function(slave, rule) {
	if (!slave || !rule || (!rule.assignment && !rule.facility))
		return false;
	var assignment = rule.assignment.concat(expandFacilityAssignments(rule.facility));
	return assignment.includes(slave.assignment);
}

window.ruleAssignmentExcluded = function(slave, rule) {
	if (!slave || !rule || (!rule.excludeAssignment && !rule.excludeFacility))
		return false;
	var excludeAssignment = rule.excludeAssignment.concat(expandFacilityAssignments(rule.excludeFacility));
	return excludeAssignment.includes(slave.assignment);
}

window.hasSurgeryRule = function(slave, rules) {
	if (!slave || !rules || !slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d].autoSurgery > 0) {
				return true;
			}
		}
	}
	return false;
};

window.hasRuleFor = function(slave, rules, what) {
	if (!slave || !rules || !slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d][what] !== "no default setting") {
				return true;
			}
		}
	}
	return false;
};

window.hasHColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hColor");
}

window.hasHStyleRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hStyle");
};

window.hasEyeColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "eyeColor");
};

window.lastPregRule = function(slave, rules) {
	if (!slave || !rules)
		return null;
	if (!slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d].preg == -1) {
				return true;
			}
		}
	}

	return null;
};

window.autoSurgerySelector = function(slave, ruleset) {

	var appRules = ruleset.filter(function(rule){
			return (rule.autoSurgery == 1) && this.currentRules.contains(rule.ID);
		}, slave);

	var surgery = {eyes: "no default setting", lactation: "no default setting", cosmetic: "nds", accent: "no default setting", shoulders: "no default setting", shouldersImplant: "no default setting", boobs: "no default setting", hips: "no default setting", hipsImplant: "no default setting", butt: "no default setting", faceShape: "no default setting", lips: "no default setting", holes: "nds", bodyhair: "nds", hair: "nds", bellyImplant: "no default setting"};
	var i, key, ruleSurgery;

	for (i in appRules)
	{
		ruleSurgery = appRules[i].surgery;
		for (key in ruleSurgery)
		{
			if (ruleSurgery[key] != "no default setting" || ruleSurgery[key] != "nds")
			{	
				surgery[key] = ruleSurgery[key];
			}
		}
	}

	return surgery;
}

window.mergeRules = function(rules) {
    var combinedRule = {};

    for (var i = 0; i < rules.length; i++) {
        for (var prop in rules[i]) {
            // A rule overrides any preceding ones if,
            //   * there are no preceding ones,
            //   * or it sets autoBrand,
            //   * or it does not set autoBrand and is not "no default setting"
            var applies = (
                combinedRule[prop] === undefined
                || (prop === "autoBrand" && rules[i][prop])
                || (prop !== "autoBrand" && rules[i][prop] !== "no default setting")
            );

            if (applies)
            {

            	//Objects in JS in operations "=" pass by reference, so we need a completely new object to avoid messing up previous rules.
            	if ("object" == typeof rules[i][prop] && "object" != typeof combinedRule[prop])
            		combinedRule[prop] = new Object();

            	//If we already have object - now we will process its properties, but object itself should be skipped.
            	if ("object" != typeof combinedRule[prop])
                	combinedRule[prop] = rules[i][prop];

            	//Some properties of rules now have second level properties. We need to check it, and change ones in combinedRule. (Good example - growth drugs. Breasts, butt, etc...) 
            	if ( "object" == typeof rules[i][prop])
    	        {
	            	for (var subprop in rules[i][prop])
    	        	{
    	           		var subapplies = (
            	    	combinedRule[prop][subprop] === undefined
                			|| (rules[i][prop][subprop] !== "no default setting")
	            		);

		            	if (subapplies)
    		            	combinedRule[prop][subprop] = rules[i][prop][subprop];
    		        }

            	}
           	}

        }

    }
    return combinedRule;
}

// rulesassistant.tw

function panic(message) {
    message = message || "panic";
    if (typeof Error !== "undefined") {
        throw new Error(message);
    }
    throw message;
}

function assert(condition, message) {
    if (!condition)
        panic(message || "Assertion failed");
}


window.isSimpleCondition = function(expr, validNames) {
    assert(validNames, "validNames was not given");

    switch (expr.id) {
    case "true": case "false":
        return true;

    case "<": case "<=": case ">": case ">=":
        return (
            expr.first.id === "(name)"              // first operand should be a name
            && validNames.includes(expr.first.name) // among the valid ones
            && expr.second.id === "(number)"        // and second should be a literal
        );

    case "&&": case "||":
        return (
            (expr.first.id == "<" || expr.first.id == "<=")
            && (expr.second.id == ">" || expr.second.id == ">=")
            && isSimpleCondition(expr.first, validNames)
            && isSimpleCondition(expr.second, validNames)
            && expr.first.first.name === expr.second.first.name
        );
    }
    return false;
}


window.getVariable = function(expr) {
    switch (expr.id) {
    case "true":
        return "always";
    case "false":
        return "none";
    case "<": case "<=": case ">": case ">=":
        return expr.first.name === "energy" ? "sex drive" : expr.first.name;
    case "&&": case "||":
        return getVariable(expr.first);
    }
}

window.changeVariable = function(expr, newVar) {
    //assert(isSimpleCondition(expr), "expr is not simple");

    switch (expr.id) {
    case "true": case "false":
        return {
            id: "<",
            first: {id: "(name)", name: newVar},
            second: {id: "(number)", value: 0}
        };

    case "<": case "<=": case ">": case ">=":
        expr.first.name = newVar;
        return expr;

    case "&&": case "||":
        expr.first.first.name = newVar;
        expr.second.first.name = newVar;
        return expr;
    }
}


window.changeComparison = function(expr, newComparison) {
    assert(expr.id !== "true" && expr.id !== "false", "expr is constant");
    //assert(isSimpleCondition(expr), "expr is not simple");

    var newOperand = {
        id: newComparison,
        first: {id: "(name)", name: expr.first.name},
        second: {id: "(number)", value: 0}
    };

    if (newComparison === "<" || newComparison === "<=") {
        switch (expr.id) {
        case "<": case "<=":
            expr.id = newComparison;
            return expr;
        case ">": case ">=":
            return { id: "&&", first: newOperand, second: expr };
        case "&&": case "||":
            expr.first.id = newComparison;
            return expr;
        }
    } else {
        switch (expr.id) {
        case "<": case "<=":
            return { id: "&&", first: expr, second: newOperand };
        case ">": case ">=":
            expr.id = newComparison;
            return expr;
        case "&&": case "||":
            expr.second.id = newComparison;
            return expr;
        }
    }
}

window.removeComparison = function(expr, comparisonType) {
    assert(expr.id !== "true" && expr.id !== "false", "expr is constant");
    //assert(isSimpleCondition(expr), "expr is not simple");
    assert(comparisonType === "lower" || comparisonType === "upper",
           "invalid comparisonType '" + comparisonType + "'");

    if (comparisonType === "lower") {
        switch (expr.id) {
        case "<": case "<=":
            return expr;
        case ">": case ">=":
            return { id: "true" };
        case "&&": case "||":
            return expr.first;
        }
    } else {
        switch (expr.id) {
        case "<": case "<=":
            return { id: "false" };
        case ">": case ">=":
            return expr;
        case "&&": case "||":
            return expr.second;
        }
    }
}


window.changeConnective = function(expr, newConnective) {
    switch (expr.id) {
    case "true": case "false":
    case "<": case "<=": case ">": case ">=":
        return expr;
    case "&&": case "||":
        expr.id = newConnective;
        return expr;
    }
}


window.unparseExpr = function(expr) {
    switch (expr.id) {

    // literals
    case "true":
        return "true";
    case "false":
        return "false";
    case "(number)": case "(string)":
        return expr.value;

    // names
    case "(name)":
        return expr.name;

    // logical infix operators
    case "&&": case "||":
    // numerical infix comperators
    case "<": case "<=":
    case ">": case ">=":
    case "=": case "!=":
    // numerical infix operators (excluding minus)
    case "+": case "*": case "/": case "^":
        return [unparseExpr(expr.first),
                expr.id,
                unparseExpr(expr.second)].join(" ");

    // unary/prefix operators
    case "!":
        return expr.id + unparseExpr(expr.first);

    case "-":
        if (expr.second !== undefined) {
            return unparseExpr(expr.first) + " - " + unparseExpr(expr.second);
        } else {
            return "-" + unparseExpr(expr.first);
        }

    // parentheses
    case "(":
        return "(" + unparseExpr(expr.first) + ")";
    }

    panic("how did I get here? unknown expr.id: " + expr.id);
}

window.typeExpr = function(expr, env) {
    switch (expr.id) {

    case "true": case "false":
        return "bool";
    case "(number)":
        return "number";
    case "(string)":
        return "string";

    case "(name)":
        return env[expr.name];

    case "&&": case "||":
        return "bool";

    case "<": case "<=":
    case ">": case ">=":
        return "bool";
    case "=": case "!=":
        return "bool";

    case "*": case "/":  case "^":
        return "number";

    case "+":
        return typeExpr(expr.first, env) === "string" ? "string" : "number";

    case "!":
        return typeExpr(expr.first, env);
    case "-":
        if (expr.second !== undefined) {
            return "number";
        } else {
            return typeExpr(expr.first, env);
        }

    case "(":
        return typeExpr(expr.first, env);
    }
}

window.optimizeExpr = function(expr) {
    switch (expr.id) {
    case "true": case "false":
    case "(number)": case "(string)":
    case "(name)":
        return expr;

    case "-":
        // The only "optimization" we are doing.  Obviously, this is not done
        // for the sake of speed, rather, to make the UI and isSimpleCondition
        // simpler, since they don't have to explicitly check for negative
        // numbers.
        if (expr.second === undefined && expr.first.id === "(number)")
            return {id: "(number)", value: evalExpr(expr)};
        // fallthrough, if the minus was not unary

    case "&&": case "||":
    case "<": case "<=": case ">": case ">=":
    case "=": case "!=":
    case "+": case "*": case "/": case "^":
        return {
            id: expr.id,
            first: optimizeExpr(expr.first),
            second: optimizeExpr(expr.second)
        };

    case "!": case "(":
        return {
            id: expr.id,
            first: optimizeExpr(expr.first)
        };
    }
}

window.printError = function(exprStr, error) {
    var result = [],
        inError = false;
    for (var i = 0; i < exprStr.length; i++) {
        if (i === error.index)
            result.push("@@.red;");
        result.push(exprStr[i]);
    }
    result.push("@@");
    return result.join("");
}
*/


// checks if any rules apply on the slave, and applies them
window.CheckAutoRulesActivate = function CheckAutoRulesActivate(slave) {
	const V = State.variables
	let r = ""

	if (slave.currentRules === undefined || slave.currentRules.length < 1)
		slave.currentRules = []

	V.defaultRules.forEach(rule => {
		let applies = evalExpr(rule, slave)
		if (applies) {
			if (!ruleApplied(slave, rule.ID)) {
				slave.currentRules.push(rule.ID)
				r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) now applies to ${slave.slaveName}, who is assigned to ${slave.assignment}</span>\n`
			}
		} else if (ruleApplied(slave, rule.ID))
			r += RARemoveRule(slave, rule)
	})
	return r
}

// remove the RA rule from the slave
window.RARemoveRule = function RARemoveRule(slave, rule) {
	let r = ""
	const idx = slave.currentRules.indexOf(
	slave.currentRules.some((rule, i) => {
		if (rule.ID === rule) {
			slave.currentRules.splice(i, 1)
			r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) no longer applies to {slave.slaveName}, who is assignmed to ${slave.assignment}</span>`
			r += RAFacilityRemove(slave, rule)
			return true
		} else return false
	})
	return r
}

// remove slave from the facility described by the rule
window.RAFacilityRemove = function RAFacilityRemove(slave, rule) {
	const V = State.variables
	let r = ""
	if (!rule.facilityRemove) return r
	switch(rule.setAssignment) {
	case "be confined in the arcade":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.arcadeName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the brothel":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.brothelName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the club":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${clubName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the dairy":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.dairyName} and has been assigned to $rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "rest in the spa":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.spaName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "get treatment in the clinic":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.clinicName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the master suite":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.masterSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "live with your Head Girl":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${HGSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work as a servant":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.servantsQuartersName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "learn in the schoolroom":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.schoolroomName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "be confined in the cellblock":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.cellblockName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;
	}
}

// return whether the rule applies to the slave
window.evalExpr = function(rule, slave) {
	let flag
	const expr = rule.condition

	switch (expr.id) {
	case "true":
		flag = true;
		break
	case "false":
		flag = false;
		break
	case "(number)":
		flag = expr.value;
		break
	case "(string)":
		if(expr.value.startsWith('"') && expr.value.endsWith('"')) {
			flag = JSON.parse(expr.value);
		} else {
			flag = expr.value;
		}
		break
	case "(name)":
		flag = slave[expr.name];
		break
	case "&&":
		flag = evalExpr(expr.first, slave) && evalExpr(expr.second, slave);
		break
	case "||":
		flag = evalExpr(expr.first, slave) || evalExpr(expr.second, slave);
		break
	case "<":
		flag = evalExpr(expr.first, slave) < evalExpr(expr.second, slave);
		break
	case "<=":
		flag = evalExpr(expr.first, slave) <= evalExpr(expr.second, slave);
		break
	case ">":
		flag = evalExpr(expr.first, slave) > evalExpr(expr.second, slave);
		break
	case ">=":
		flag = evalExpr(expr.first, slave) >= evalExpr(expr.second, slave);
		break
	case "=":
		flag = evalExpr(expr.first, slave) == evalExpr(expr.second, slave);
		break
	case "!=":
		flag = evalExpr(expr.first, slave) != evalExpr(expr.second, slave);
		break
	case "+":
		flag = evalExpr(expr.first, slave) + evalExpr(expr.second, slave);
		break
	case "*":
		flag = evalExpr(expr.first, slave) * evalExpr(expr.second, slave);
		break
	case "/":
		flag = evalExpr(expr.first, slave) / evalExpr(expr.second, slave);
		break
	case "^":
		flag = Math.pow(evalExpr(expr.first, slave), evalExpr(expr.second, slave));
		break
	case "!":
		flag = !evalExpr(expr.first, slave);
		break
	case "-":
		if (expr.second !== undefined) {
			flag = evalExpr(expr.first, slave) - evalExpr(expr.second, slave);
		} else {
			flag = -evalExpr(expr.first, slave);
		}
		break
	case "(":
		flag = evalExpr(expr.first, slave);
		break
	}

	if (flag && rule.excludeSpecialSlaves && isLeaderP(slave))
		flag = false
	else if (flag) {
		if (rule.assignment.length > 0 || rule.facility.length > 0)
			flag = ruleAssignmentSelected(slave, rule)
		else if (rule.excludeAssignment.length > 0 || rule.excludeFacility.length > 0)
			flag = !ruleAssignmentExcluded(slave, rule)
		if (rule.selectedSlaves.length > 0)
			flag = ruleSlaveSelected(slave, rule)
		else if (rule.excludedSlaves.length > 0)
			flag = !ruleSlaveExcluded(slave, rule)
	}
	return flag
}

// raSelectorJS

/*

window.growAdvSelector = function(slave, rule) {

	var ret = "";
	var setd = 0;

	if ((rule.breastSize == "small" && slave.boobs < 350) ||
		(rule.breastSize == "c-cup" && slave.boobs < 550) ||
		(rule.breastSize == "f-cup" && slave.boobs < 1100) ||
		(rule.breastSize == "k-cup" && slave.boobs < 2150) ||
		(rule.breastSize == "p-cup" && slave.boobs < 3700) ||
		(rule.breastSize == "unlimited" && slave.boobs < 24000))	
	{ 
		slave.drugs = "breast injections"; 
		ret = slave.slaveName + "'s boobs could be bigger, so she's been put on breast injections.";
		return ret;
	}
	
	if ((rule.buttSize == "small" && slave.butt < 1) ||
		(rule.buttSize == "plump" && slave.butt < 3) ||
		(rule.buttSize == "huge" && slave.butt < 4) ||
		(rule.buttSize == "enormous" && slave.butt < 6) ||
		(rule.buttSize == "unlimited" && slave.butt < 19))	
	{ 
		slave.drugs = "butt injections"; 
		ret = slave.slaveName + "'s butt could be bigger, so she's been put on butt injections.";
		return ret;
	}

	if (slave.balls > 0 &&
		((rule.ballSize == "small" && slave.balls < 2) ||
		 (rule.ballSize == "big" && slave.balls < 4) ||
		 (rule.ballSize == "huge" && slave.balls < 6) ||
		 (rule.ballSize == "unlimited" && slave.balls < 9)))		
	{ 
		slave.drugs = "testicle enhancement"; 
		ret = slave.slaveName + "'s balls aren't large enough, so she's been put on testicle enhancement.";
		return ret;
	}

	if (slave.dick > 0 &&
		((rule.penisSize == "small" && slave.dick < 2) ||
		 (rule.penisSize == "big" && slave.dick < 4) ||
		 (rule.penisSize == "huge" && slave.dick < 6) ||
		 (rule.penisSize == "unlimited" && slave.dick < 12)))
	{ 
		slave.drugs = "penis enhancement"; 
		ret = slave.slaveName + "'s dick isn't large enough, so she's been put on penis enhancement.";
		return ret;
	}

	if ((rule.lipSize == "normal" && slave.lips < 15) ||
		(rule.lipSize == "pretty" && slave.lips < 30) ||
		(rule.lipSize == "plush" && slave.lips < 55) ||
		(rule.lipSize == "huge" && slave.lips < 85) ||
		(rule.lipSize == "facepussy" && slave.lips < 99))	
	{ 
		slave.drugs = "lip injections"; 
		ret = slave.slaveName + "'s lips aren't large enough, so she's been put on lips enhancement.";
		return ret;
	}

	if (slave.drugs != "no drugs")
	{
		slave.drugs = "no drugs";
		ret = slave.slaveName + " has reached growth targets and has been taken off growth injections.";
	}

	return ret;

}

window.growAdvSelectorSlim = function(slave, rule) {

	var ret = "";
	var setd = 0;

	if ((rule.breastSize == "small" && slave.boobs > 350) ||
		(rule.breastSize == "c-cup" && slave.boobs > 550) ||
		(rule.breastSize == "f-cup" && slave.boobs > 1100) ||
		(rule.breastSize == "k-cup" && slave.boobs > 2150) ||
		(rule.breastSize == "p-cup" && slave.boobs > 3700))	
	{ 
		slave.drugs = "breast redistributors"; 
		ret = slave.slaveName + "'s boobs are too big, so she's been put on breast reduction drugs.";
		return ret;
	}
	
	if ((rule.buttSize == "small" && slave.butt > 1) ||
		(rule.buttSize == "plump" && slave.butt > 3) ||
		(rule.buttSize == "huge" && slave.butt > 4) ||
		(rule.buttSize == "enormous" && slave.butt > 6))	
	{ 
		slave.drugs = "butt redistributors"; 
		ret = slave.slaveName + "'s butt is too big, so she's been put on butt reduction drugs.";
		return ret;
	}

	if ((rule.ballSize == "small" && slave.balls > 2) ||
		(rule.ballSize == "big" && slave.balls > 4) ||
		(rule.ballSize == "huge" && slave.balls > 6))	
	{ 
		slave.drugs = "testicle atrophiers"; 
		ret = slave.slaveName + "'s balls are too big, so she's been put on testicle atrophiers.";
		return ret;
	}

	if ((rule.penisSize == "small" && slave.dick > 2) ||
		(rule.penisSize == "big" && slave.dick > 4) ||
		(rule.penisSize == "huge" && slave.dick > 6))	
	{ 
		slave.drugs = "penis atrophiers"; 
		ret = slave.slaveName + "'s dick is too big, so she's been put on penis atrophiers.";
		return ret;
	}

	if ((rule.lipSize == "normal" && slave.lips > 15) ||
		(rule.lipSize == "pretty" && slave.lips > 30) ||
		(rule.lipSize == "plush" && slave.lips > 55) ||
		(rule.lipSize == "huge" && slave.lips > 85))	
	{ 
		slave.drugs = "lip atrophiers"; 
		ret = slave.slaveName + "'s lips are too big, so she's been put on lips atrophiers.";
		return ret;
	}

	if (slave.drugs != "no drugs")
	{
		slave.drugs = "no drugs";
		ret = slave.slaveName + " has reached growth targets and has been taken off growth injections.";
	}

	return ret;
}

// rulesAssistantParser

:: rulesAssistantParser [script]

// Implements a Top Down Operator Precedence parser, also know as a Pratt
// parser, after its "inventor", Vaughan Pratt.  The one implemented here
// closely follows what's presented here,
//     * http://javascript.crockford.com/tdop/tdop.html
// by Douglas Crockford, that uses that technique in JSLint.  Other relevant
// resources on the interweb
//     * http://effbot.org/zone/simple-top-down-parsing.htm
//     * http://eli.thegreenplace.net/2010/01/02/top-down-operator-precedence-parsing
//     * http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/
//     * https://higherlogics.blogspot.gr/2009/11/extensible-statically-typed-pratt.html
//     * https://github.com/fholm/Vaughan
//     * https://github.com/DasIch/pratt
// included here mostly as bookmarks for potential future reference.
//
// With regards to the lexer, I used the following with many changes
//     * http://eli.thegreenplace.net/2013/06/25/regex-based-lexical-analysis-in-python-and-javascript/
//
// Other useful things that I may not use any more but wouldn't want to lose,
//     * https://plainjs.com/javascript/utilities/merge-two-javascript-objects-19/
//     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions


function panic(index, msg) {
    throw {index: index, message: msg};
}

var Lexer = function(skipWhitespace) {
    this.rules = [];
    this.index = 0;
    this.buffer = "";
    this.skipWhitespace = skipWhitespace ? /\S/ : null;
}

Lexer.prototype.addRule = function(id, defn) {
    var pattern = (defn && defn.pattern) || RegExp.escape(id);
    this.rules.push({
        id: id,
        pattern: new RegExp('^' + pattern)
    });
}

Lexer.prototype.feed = function(buffer) {
    this.buffer = buffer;
    this.index = 0;
}

Lexer.prototype.nextInterestingChar = function() {
    if (this.skipWhitespace) {
        var match = this.skipWhitespace.exec(this.buffer.substr(this.index));
        return match ? this.index + match.index
                     : this.buffer.length;
    }
    return this.index;
}

Lexer.prototype.next = function() {
    this.index = this.nextInterestingChar();

    if (this.index >= this.buffer.length)
        return { done: true };

    for (var i = 0; i < this.rules.length; ++i) {
        var rule = this.rules[i],
            match = rule.pattern.exec(this.buffer.substr(this.index));
        if (match) {
            var token = {
                id: rule.id,
                value: match[0],
                index: this.index,
            };
            this.index += token.value.length;
            return { done: false, value: token };
        }
    }

    panic(this.index, "illegal character");
}



var BaseSymbol = {
    lbp: 0,
    nud: function() { panic(this.index, "unexpected '" + this.id + "'"); },
    led: function() { panic(this.index, "not an operator"); }
};

var Parser = function(eofToken) {
    this.lexer = new Lexer(true);
    this.currentSymbol = null;

    this.eofToken = eofToken;
    this.symbolTable = {
        [this.eofToken]: Object.create(BaseSymbol, {id: {value: this.eofToken}})
    };
}

Parser.prototype.addSymbol = function(id, defn) {
    var s = this.symbolTable[id];
    if (s) {
        if (defn) {
            if (defn.lbp !== undefined) s.lbp = defn.lbp;
            if (defn.nud !== undefined) s.nud = defn.nud;
            if (defn.led !== undefined) s.led = defn.led;
        }
    } else {
        s = Object.create(BaseSymbol);
        s.id = id;
        if (defn && defn.lbp !== undefined) s.lbp = defn.lbp;
        if (defn && defn.nud) s.nud = defn.nud;
        if (defn && defn.led) s.led = defn.led;
        this.symbolTable[id] = s;
        this.lexer.addRule(id, defn);
    }
    return this;
}

Parser.prototype.addInfix = function(id, lbp, callback) {
    this.addSymbol(id, {
        lbp: lbp,
        led: function(p, left) { return callback(this, left, p.parse(lbp)); }
    });
    return this;
}

Parser.prototype.addInfixR = function(id, lbp, callback) {
    this.addSymbol(id, {
        lbp: lbp,
        led: function(p, left) { return callback(this, left, p.parse(lbp-1)); }
    });
    return this;
}

Parser.prototype.addPrefix = function(id, callback) {
    this.addSymbol(id, {
        // FIXME: this should not always be 70
        nud: function (p) { return callback(this, p.parse(70)); }
    });
    return this;
}

Parser.prototype.addConstant = function(id, callback) {
    this.addSymbol(id, {
        nud: function () { return callback(this); }
    });
    return this;
}

Parser.prototype.advance = function(id) {
    if (id !== undefined && this.currentSymbol.id !== id)
        panic(this.currentSymbol.index, "expected '" + id + "', got '" + this.currentSymbol.id + "'");

    var iter = this.lexer.next(),
        token = iter.value;
    if (iter.done)
        token = {
            id: this.eofToken,
            index: this.lexer.buffer.length
        };

    var symbol = this.symbolTable[iter.done ? this.eofToken : token.id];
    if (!symbol)
        panic(token.index, "unknown token '" + token.id + "'");

    var newSymbol = Object.create(symbol);
    newSymbol.value = token.value;
    newSymbol.index = token.index;
    return this.currentSymbol = newSymbol;
}

Parser.prototype.parse = function(rbp) {
    var symbol = this.currentSymbol;
    this.advance();
    var left = symbol.nud(this);

    rbp = rbp || 0;
    while (rbp < this.currentSymbol.lbp) {
        symbol = this.currentSymbol;
        this.advance();
        left = symbol.led(this, left);
    }
    return left;
}

Parser.prototype.parseString = function(string) {
    this.lexer.feed(string);
    this.advance();  // "kickstart" the lexer
    var result = this.parse();
    this.advance(this.eofToken);
    return result;
}



var ASTBuilder = function(eofToken) {
    this.parser = new Parser(eofToken);
}

ASTBuilder.prototype.addSymbol = function(id, extra) {
    this.parser.addSymbol(id, extra);
    return this;
}

ASTBuilder.prototype.addInfix = function(id, lbp) {
    this.parser.addInfix(id, lbp, function(symbol, left, right) {
        return {
            id: id,
            first: left,
            second: right,
        };
    });
    return this;
}

ASTBuilder.prototype.addInfixR = function(id, lbp) {
    this.parser.addInfixR(id, lbp, function(symbol, left, right) {
        return {
            id: id,
            first: left,
            second: right,
        };
    });
    return this;
}

ASTBuilder.prototype.addPrefix = function(id) {
    this.parser.addPrefix(id, function(symbol, left) {
        return {
            id: id,
            first: left,  // it's not really the left is it?
        };
    });
    return this;
}

ASTBuilder.prototype.addConstant = function(id, value) {
    this.parser.addConstant(id, function(symbol) {
        return {
            id: id,
            value: value,
        };
    });
    return this;
}


var op = {
    add: function(a, b) { return a + b; },
    sub: function(a, b) { return a - b; },
    mul: function(a, b) { return a * b; },
    div: function(a, b) { return a / b; },
    pow: function(a, b) { return Math.pow(a, b); },

    neg: function(a) { return -a; },

    lt: function(a, b) { return a < b; },
    le: function(a, b) { return a <= b; },
    gt: function(a, b) { return a > b; },
    ge: function(a, b) { return a >= b; },
    eq: function(a, b) { return a === b; },
    neq: function(a, b) { return a !== b; },

    not: function(a) { return !a; },
    or: function(a, b) { return a || b; },
    and: function(a, b) { return a && b; },
};

var parserBuilder = new ASTBuilder("(end)")
    // XXX: need to be first to not be recognised as a (name)
    .addConstant("true", true)
    .addConstant("false", false)

    .addSymbol("(number)", {
        pattern: "\\d+",
        nud: function() {
            return {
                id: "(number)",
                value: parseInt(this.value),
            };
        }
    })

    .addSymbol("(string)", {
        pattern: "\"(?:[^\\\\\"]|\\\\\"|\\\\(?!\"))*\"",
        nud: function(p) {
            return {
                id: "(string)",
                value: this.value.replace(/^\"|\"$/g, ""),
            };
        }
    })

    .addSymbol("(name)", {
        pattern: "[a-zA-Z]\\w*",
        nud: function(p) {
            return {
                id: "(name)",
                name: this.value,
            };
        }
    })

    .addInfix("+", 50,  op.add)
    .addInfix("-", 50,  op.sub)
    .addInfix("*", 60,  op.mul)
    .addInfix("/", 60,  op.div)
    .addInfixR("^", 70, op.pow)

    .addPrefix("-", op.neg)

    .addInfix("<=", 40, op.le)
    .addInfix("<",  40, op.lt)
    .addInfix(">=", 40, op.ge)
    .addInfix(">",  40, op.gt)
    .addInfix("!=", 40, op.neq)
    .addInfix("=",  40, op.eq)

    .addPrefix("!", op.not)
    .addInfix("||", 30, op.or)
    .addInfix("&&", 30, op.and)

    .addSymbol(")")
    .addSymbol("(", {
        nud: function(p) {
            var expr = p.parse(0);
            p.advance(")");
            return expr;
        }
    });

var parser = parserBuilder.parser;
window.parser = parser;

window.parseCondition = function(condition) {
    try {
        return {expr: parser.parseString(condition), error: null};
    } catch (e) {
        return {expr: null, error: e};
    }
}

*/
