:: rulesAssistant [script]

// RAJS

window.hasSurgeryRule = function(slave, rules) {
	return rules.some(rule => {
		if (ruleApplied(slave, rule.ID) && rule.autoSurgery > 0)
			return true;
		else return false;
	})
};

/*
window.hasRuleFor = function(slave, rules, what) {
	if (!slave || !rules || !slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d][what] !== "no default setting") {
				return true;
			}
		}
	}
	return false;
};

window.hasHColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hColor");
}

window.hasHStyleRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hStyle");
};

window.hasEyeColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "eyeColor");
};

window.lastPregRule = function(slave, rules) {
	if (!slave || !rules)
		return null;
	if (!slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d].preg == -1) {
				return true;
			}
		}
	}

	return null;
};

window.mergeRules = function(rules) {
    var combinedRule = {};

    for (var i = 0; i < rules.length; i++) {
        for (var prop in rules[i]) {
            // A rule overrides any preceding ones if,
            //   * there are no preceding ones,
            //   * or it sets autoBrand,
            //   * or it does not set autoBrand and is not "no default setting"
            var applies = (
                combinedRule[prop] === undefined
                || (prop === "autoBrand" && rules[i][prop])
                || (prop !== "autoBrand" && rules[i][prop] !== "no default setting")
            );

            if (applies)
            {

            	//Objects in JS in operations "=" pass by reference, so we need a completely new object to avoid messing up previous rules.
            	if ("object" == typeof rules[i][prop] && "object" != typeof combinedRule[prop])
            		combinedRule[prop] = new Object();

            	//If we already have object - now we will process its properties, but object itself should be skipped.
            	if ("object" != typeof combinedRule[prop])
                	combinedRule[prop] = rules[i][prop];

            	//Some properties of rules now have second level properties. We need to check it, and change ones in combinedRule. (Good example - growth drugs. Breasts, butt, etc...) 
            	if ( "object" == typeof rules[i][prop])
    	        {
	            	for (var subprop in rules[i][prop])
    	        	{
    	           		var subapplies = (
            	    	combinedRule[prop][subprop] === undefined
                			|| (rules[i][prop][subprop] !== "no default setting")
	            		);

		            	if (subapplies)
    		            	combinedRule[prop][subprop] = rules[i][prop][subprop];
    		        }

            	}
           	}

        }

    }
    return combinedRule;
}
*/

window.mergeRules = function mergeRules(rules) {
	const combinedRule = {};
	rules.forEach(rule => {
		// A rule overrides any preceding ones if,
		//   * there are no preceding ones,
		//   * or it sets autoBrand,
		//   * or it does not set autoBrand and is not "no default setting"
		Object.keys(rule).forEach(key => {
			const applies = (combinedRule[key] === undefined ||
				(key === "autoBrand" && rule[key]) ||
				(key !== "autoBrand" && rule[key] !== "no default setting"));
			if (!applies) return
			combinedRule[key] = rule[key]
		})
	})
}

// return if a rule is applied on a slave
window.ruleApplied = function(slave, rule) {
	return slave.currentRules.includes(rule.ID);
};

// checks if any rules apply on the slave, and applies them
window.CheckAutoRulesActivate = function CheckAutoRulesActivate(slave) {
	const V = State.variables
	let r = ""

	V.defaultRules.forEach(rule => {
		let applies = ruleAppliesP(rule.condition, slave)
		if (applies) {
			if (!ruleApplied(slave, rule)) {
				slave.currentRules.push(rule.ID)
				r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) now applies to ${slave.slaveName}, who is assigned to ${slave.assignment}</span>\n`
			}
		} else if (ruleApplied(slave, rule))
			r += RARemoveRule(slave, rule)
	})
	return r
}

// remove the RA rule from the slave
window.RARemoveRule = function RARemoveRule(slave, rule) {
	let r = ""
	const index = slave.currentRules.findIndex(rule => rule.ID === rule)
	if (index === -1) return r
	const slave_rule = slave.currentRules[index];
	slave.currentRules.splice(index, 1)
	r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) no longer applies to ${slave.slaveName}, who is assignmed to ${slave.assignment}</span>`
	r += RAFacilityRemove(slave, slave_rule.set)
	return r
}

// remove slave from the facility described by the rule
window.RAFacilityRemove = function RAFacilityRemove(slave, rule) {
	const V = State.variables
	let r = ""
	if (!rule.facilityRemove) return r
	switch(rule.setAssignment) {
	case "be confined in the arcade":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.arcadeName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the brothel":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.brothelName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the club":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${clubName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the dairy":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.dairyName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "rest in the spa":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.spaName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "get treatment in the clinic":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.clinicName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the master suite":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.masterSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "live with your Head Girl":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${HGSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work as a servant":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.servantsQuartersName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "learn in the schoolroom":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.schoolroomName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "be confined in the cellblock":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.cellblockName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;
	}
}

// return whether the rule applies to the slave
window.ruleAppliesP = function ruleAppliesP(cond, slave) {
	let flag

	// attribute / function check
	switch (cond.function) {
	case true: // always applies
		flag = true;
		break;
	case false: // never applies
		flag = false;
		break;
	case "between": // between two values of a slave's attribute
		return between(
			slave[cond.data.attribute],
			cond.data.value[0],
			cond.data.value[1])
		break;
	case "custom": // user provided JS function
		return eval(data)
		break;
	}
	// assignment / facility / special slaves / specific slaves check
	flag = flag &&
		!(cond.excludeSpecialSlaves && isLeaderP(slave)) &&
		cond.assignment.includes(slave.assignment) &&
		!cond.excludeAssignment.includes(slave.assignment) &&
		cond.facility.includes(slave.assignment) &&
		!cond.excludeFacility.includes(slave.assignment) &&
		cond.selectedSlaves.includes(slave.ID) &&
		!cond.excludedSlaves.includes(slave.ID)
	return flag
}
