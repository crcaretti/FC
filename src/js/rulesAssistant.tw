:: rulesAssistant [script]

// RAJS
/*

window.hasSurgeryRule = function(slave, rules) {
	if (!slave || !rules || !slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d].autoSurgery > 0) {
				return true;
			}
		}
	}
	return false;
};

window.hasRuleFor = function(slave, rules, what) {
	if (!slave || !rules || !slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d][what] !== "no default setting") {
				return true;
			}
		}
	}
	return false;
};

window.hasHColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hColor");
}

window.hasHStyleRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "hStyle");
};

window.hasEyeColorRule = function(slave, rules) {
	return hasRuleFor(slave, rules, "eyeColor");
};

window.lastPregRule = function(slave, rules) {
	if (!slave || !rules)
		return null;
	if (!slave.currentRules)
		return false;

	for (var d = rules.length-1; d >= 0; d--) {
		if (ruleApplied(slave, rules[d].ID)) {
			if (rules[d].preg == -1) {
				return true;
			}
		}
	}

	return null;
};

window.autoSurgerySelector = function(slave, ruleset) {

	var appRules = ruleset.filter(function(rule){
			return (rule.autoSurgery == 1) && this.currentRules.contains(rule.ID);
		}, slave);

	var surgery = {eyes: "no default setting", lactation: "no default setting", cosmetic: "nds", accent: "no default setting", shoulders: "no default setting", shouldersImplant: "no default setting", boobs: "no default setting", hips: "no default setting", hipsImplant: "no default setting", butt: "no default setting", faceShape: "no default setting", lips: "no default setting", holes: "nds", bodyhair: "nds", hair: "nds", bellyImplant: "no default setting"};
	var i, key, ruleSurgery;

	for (i in appRules)
	{
		ruleSurgery = appRules[i].surgery;
		for (key in ruleSurgery)
		{
			if (ruleSurgery[key] != "no default setting" || ruleSurgery[key] != "nds")
			{	
				surgery[key] = ruleSurgery[key];
			}
		}
	}

	return surgery;
}

window.mergeRules = function(rules) {
    var combinedRule = {};

    for (var i = 0; i < rules.length; i++) {
        for (var prop in rules[i]) {
            // A rule overrides any preceding ones if,
            //   * there are no preceding ones,
            //   * or it sets autoBrand,
            //   * or it does not set autoBrand and is not "no default setting"
            var applies = (
                combinedRule[prop] === undefined
                || (prop === "autoBrand" && rules[i][prop])
                || (prop !== "autoBrand" && rules[i][prop] !== "no default setting")
            );

            if (applies)
            {

            	//Objects in JS in operations "=" pass by reference, so we need a completely new object to avoid messing up previous rules.
            	if ("object" == typeof rules[i][prop] && "object" != typeof combinedRule[prop])
            		combinedRule[prop] = new Object();

            	//If we already have object - now we will process its properties, but object itself should be skipped.
            	if ("object" != typeof combinedRule[prop])
                	combinedRule[prop] = rules[i][prop];

            	//Some properties of rules now have second level properties. We need to check it, and change ones in combinedRule. (Good example - growth drugs. Breasts, butt, etc...) 
            	if ( "object" == typeof rules[i][prop])
    	        {
	            	for (var subprop in rules[i][prop])
    	        	{
    	           		var subapplies = (
            	    	combinedRule[prop][subprop] === undefined
                			|| (rules[i][prop][subprop] !== "no default setting")
	            		);

		            	if (subapplies)
    		            	combinedRule[prop][subprop] = rules[i][prop][subprop];
    		        }

            	}
           	}

        }

    }
    return combinedRule;
}

// rulesassistant.tw

function panic(message) {
    message = message || "panic";
    if (typeof Error !== "undefined") {
        throw new Error(message);
    }
    throw message;
}

function assert(condition, message) {
    if (!condition)
        panic(message || "Assertion failed");
}


window.isSimpleCondition = function(expr, validNames) {
    assert(validNames, "validNames was not given");

    switch (expr.id) {
    case "true": case "false":
        return true;

    case "<": case "<=": case ">": case ">=":
        return (
            expr.first.id === "(name)"              // first operand should be a name
            && validNames.includes(expr.first.name) // among the valid ones
            && expr.second.id === "(number)"        // and second should be a literal
        );

    case "&&": case "||":
        return (
            (expr.first.id == "<" || expr.first.id == "<=")
            && (expr.second.id == ">" || expr.second.id == ">=")
            && isSimpleCondition(expr.first, validNames)
            && isSimpleCondition(expr.second, validNames)
            && expr.first.first.name === expr.second.first.name
        );
    }
    return false;
}


window.getVariable = function(expr) {
    switch (expr.id) {
    case "true":
        return "always";
    case "false":
        return "none";
    case "<": case "<=": case ">": case ">=":
        return expr.first.name === "energy" ? "sex drive" : expr.first.name;
    case "&&": case "||":
        return getVariable(expr.first);
    }
}

window.changeVariable = function(expr, newVar) {
    //assert(isSimpleCondition(expr), "expr is not simple");

    switch (expr.id) {
    case "true": case "false":
        return {
            id: "<",
            first: {id: "(name)", name: newVar},
            second: {id: "(number)", value: 0}
        };

    case "<": case "<=": case ">": case ">=":
        expr.first.name = newVar;
        return expr;

    case "&&": case "||":
        expr.first.first.name = newVar;
        expr.second.first.name = newVar;
        return expr;
    }
}


window.changeComparison = function(expr, newComparison) {
    assert(expr.id !== "true" && expr.id !== "false", "expr is constant");
    //assert(isSimpleCondition(expr), "expr is not simple");

    var newOperand = {
        id: newComparison,
        first: {id: "(name)", name: expr.first.name},
        second: {id: "(number)", value: 0}
    };

    if (newComparison === "<" || newComparison === "<=") {
        switch (expr.id) {
        case "<": case "<=":
            expr.id = newComparison;
            return expr;
        case ">": case ">=":
            return { id: "&&", first: newOperand, second: expr };
        case "&&": case "||":
            expr.first.id = newComparison;
            return expr;
        }
    } else {
        switch (expr.id) {
        case "<": case "<=":
            return { id: "&&", first: expr, second: newOperand };
        case ">": case ">=":
            expr.id = newComparison;
            return expr;
        case "&&": case "||":
            expr.second.id = newComparison;
            return expr;
        }
    }
}

window.removeComparison = function(expr, comparisonType) {
    assert(expr.id !== "true" && expr.id !== "false", "expr is constant");
    //assert(isSimpleCondition(expr), "expr is not simple");
    assert(comparisonType === "lower" || comparisonType === "upper",
           "invalid comparisonType '" + comparisonType + "'");

    if (comparisonType === "lower") {
        switch (expr.id) {
        case "<": case "<=":
            return expr;
        case ">": case ">=":
            return { id: "true" };
        case "&&": case "||":
            return expr.first;
        }
    } else {
        switch (expr.id) {
        case "<": case "<=":
            return { id: "false" };
        case ">": case ">=":
            return expr;
        case "&&": case "||":
            return expr.second;
        }
    }
}


window.changeConnective = function(expr, newConnective) {
    switch (expr.id) {
    case "true": case "false":
    case "<": case "<=": case ">": case ">=":
        return expr;
    case "&&": case "||":
        expr.id = newConnective;
        return expr;
    }
}


window.unparseExpr = function(expr) {
    switch (expr.id) {

    // literals
    case "true":
        return "true";
    case "false":
        return "false";
    case "(number)": case "(string)":
        return expr.value;

    // names
    case "(name)":
        return expr.name;

    // logical infix operators
    case "&&": case "||":
    // numerical infix comperators
    case "<": case "<=":
    case ">": case ">=":
    case "=": case "!=":
    // numerical infix operators (excluding minus)
    case "+": case "*": case "/": case "^":
        return [unparseExpr(expr.first),
                expr.id,
                unparseExpr(expr.second)].join(" ");

    // unary/prefix operators
    case "!":
        return expr.id + unparseExpr(expr.first);

    case "-":
        if (expr.second !== undefined) {
            return unparseExpr(expr.first) + " - " + unparseExpr(expr.second);
        } else {
            return "-" + unparseExpr(expr.first);
        }

    // parentheses
    case "(":
        return "(" + unparseExpr(expr.first) + ")";
    }

    panic("how did I get here? unknown expr.id: " + expr.id);
}

window.typeExpr = function(expr, env) {
    switch (expr.id) {

    case "true": case "false":
        return "bool";
    case "(number)":
        return "number";
    case "(string)":
        return "string";

    case "(name)":
        return env[expr.name];

    case "&&": case "||":
        return "bool";

    case "<": case "<=":
    case ">": case ">=":
        return "bool";
    case "=": case "!=":
        return "bool";

    case "*": case "/":  case "^":
        return "number";

    case "+":
        return typeExpr(expr.first, env) === "string" ? "string" : "number";

    case "!":
        return typeExpr(expr.first, env);
    case "-":
        if (expr.second !== undefined) {
            return "number";
        } else {
            return typeExpr(expr.first, env);
        }

    case "(":
        return typeExpr(expr.first, env);
    }
}

window.optimizeExpr = function(expr) {
    switch (expr.id) {
    case "true": case "false":
    case "(number)": case "(string)":
    case "(name)":
        return expr;

    case "-":
        // The only "optimization" we are doing.  Obviously, this is not done
        // for the sake of speed, rather, to make the UI and isSimpleCondition
        // simpler, since they don't have to explicitly check for negative
        // numbers.
        if (expr.second === undefined && expr.first.id === "(number)")
            return {id: "(number)", value: evalExpr(expr)};
        // fallthrough, if the minus was not unary

    case "&&": case "||":
    case "<": case "<=": case ">": case ">=":
    case "=": case "!=":
    case "+": case "*": case "/": case "^":
        return {
            id: expr.id,
            first: optimizeExpr(expr.first),
            second: optimizeExpr(expr.second)
        };

    case "!": case "(":
        return {
            id: expr.id,
            first: optimizeExpr(expr.first)
        };
    }
}

window.printError = function(exprStr, error) {
    var result = [],
        inError = false;
    for (var i = 0; i < exprStr.length; i++) {
        if (i === error.index)
            result.push("@@.red;");
        result.push(exprStr[i]);
    }
    result.push("@@");
    return result.join("");
}
*/

window.mergeRules = function mergeRules(rules) {
	const combinedRule = {};
	rules.forEach(rule => {
		// A rule overrides any preceding ones if,
		//   * there are no preceding ones,
		//   * or it sets autoBrand,
		//   * or it does not set autoBrand and is not "no default setting"
		Object.keys(rule).forEach(key => {
			const applies = (combinedRule[key] === undefined ||
				(key === "autoBrand" && rule[key]) ||
				(key !== "autoBrand" && rule[key] !== "no default setting"));
			if (!applies) return
			combinedRule[key] = rule[key]
		})
	})
}

// return if a rule is applied on a slave
window.ruleApplied = function(slave, rule) {
	return slave.currentRules.includes(rule.ID);
};

// checks if any rules apply on the slave, and applies them
window.CheckAutoRulesActivate = function CheckAutoRulesActivate(slave) {
	const V = State.variables
	let r = ""

	V.defaultRules.forEach(rule => {
		let applies = ruleAppliesP(rule.condition, slave)
		if (applies) {
			if (!ruleApplied(slave, rule)) {
				slave.currentRules.push(rule.ID)
				r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) now applies to ${slave.slaveName}, who is assigned to ${slave.assignment}</span>\n`
			}
		} else if (ruleApplied(slave, rule))
			r += RARemoveRule(slave, rule)
	})
	return r
}

// remove the RA rule from the slave
window.RARemoveRule = function RARemoveRule(slave, rule) {
	let r = ""
	slave.currentRules.some((rule, i) => {
		if (rule.ID === rule) {
			slave.currentRules.splice(i, 1)
			r += `<br><span class="tan">Rule ${rule.ID} (${rule.name}) no longer applies to ${slave.slaveName}, who is assignmed to ${slave.assignment}</span>`
			r += RAFacilityRemove(slave, rule.set)
			return true
		} else return false
	})
	return r
}

// remove slave from the facility described by the rule
window.RAFacilityRemove = function RAFacilityRemove(slave, rule) {
	const V = State.variables
	let r = ""
	if (!rule.facilityRemove) return r
	switch(rule.setAssignment) {
	case "be confined in the arcade":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.arcadeName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the brothel":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.brothelName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the club":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${clubName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work in the dairy":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.dairyName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "rest in the spa":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.spaName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "get treatment in the clinic":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.clinicName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "serve in the master suite":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>{slave.slaveName} has been removed from ${V.masterSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "live with your Head Girl":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${HGSuiteName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "work as a servant":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.servantsQuartersName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "learn in the schoolroom":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.schoolroomName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;

	case "be confined in the cellblock":
		if (slave.assignment === rule.setAssignment) {
			r += `<br>${slave.slaveName} has been removed from ${V.cellblockName} and has been assigned to ${rule.removalAssignment}.`
			assignJob(slave, rule.removalAssignment)
		}
		break;
	}
}

// return whether the rule applies to the slave
window.ruleAppliesP = function ruleAppliesP(cond, slave) {
	let flag

	// attribute / function check
	switch (cond.function) {
	case true: // always applies
		flag = true;
		break;
	case false: // never applies
		flag = false;
		break;
	case "between": // between two values of a slave's attribute
		return between(
			slave[cond.data.attribute],
			cond.data.value[0],
			cond.data.value[1])
		break;
	case "custom": // user provided JS function
		return eval(data)
		break;
	}
	// assignment / facility / special slaves / specific slaves check
	flag = flag &&
		!(cond.excludeSpecialSlaves && isLeaderP(slave)) &&
		cond.assignment.includes(slave.assignment) &&
		!cond.excludeAssignment.includes(slave.assignment) &&
		cond.facility.includes(slave.assignment) &&
		!cond.excludeFacility.includes(slave.assignment) &&
		cond.selectedSlaves.includes(slave.ID) &&
		!cond.excludedSlaves.includes(slave.ID)
	return flag
}

// raSelectorJS

/*

window.growAdvSelector = function(slave, rule) {

	var ret = "";
	var setd = 0;

	if ((rule.breastSize == "small" && slave.boobs < 350) ||
		(rule.breastSize == "c-cup" && slave.boobs < 550) ||
		(rule.breastSize == "f-cup" && slave.boobs < 1100) ||
		(rule.breastSize == "k-cup" && slave.boobs < 2150) ||
		(rule.breastSize == "p-cup" && slave.boobs < 3700) ||
		(rule.breastSize == "unlimited" && slave.boobs < 24000))	
	{ 
		slave.drugs = "breast injections"; 
		ret = slave.slaveName + "'s boobs could be bigger, so she's been put on breast injections.";
		return ret;
	}
	
	if ((rule.buttSize == "small" && slave.butt < 1) ||
		(rule.buttSize == "plump" && slave.butt < 3) ||
		(rule.buttSize == "huge" && slave.butt < 4) ||
		(rule.buttSize == "enormous" && slave.butt < 6) ||
		(rule.buttSize == "unlimited" && slave.butt < 19))	
	{ 
		slave.drugs = "butt injections"; 
		ret = slave.slaveName + "'s butt could be bigger, so she's been put on butt injections.";
		return ret;
	}

	if (slave.balls > 0 &&
		((rule.ballSize == "small" && slave.balls < 2) ||
		 (rule.ballSize == "big" && slave.balls < 4) ||
		 (rule.ballSize == "huge" && slave.balls < 6) ||
		 (rule.ballSize == "unlimited" && slave.balls < 9)))		
	{ 
		slave.drugs = "testicle enhancement"; 
		ret = slave.slaveName + "'s balls aren't large enough, so she's been put on testicle enhancement.";
		return ret;
	}

	if (slave.dick > 0 &&
		((rule.penisSize == "small" && slave.dick < 2) ||
		 (rule.penisSize == "big" && slave.dick < 4) ||
		 (rule.penisSize == "huge" && slave.dick < 6) ||
		 (rule.penisSize == "unlimited" && slave.dick < 12)))
	{ 
		slave.drugs = "penis enhancement"; 
		ret = slave.slaveName + "'s dick isn't large enough, so she's been put on penis enhancement.";
		return ret;
	}

	if ((rule.lipSize == "normal" && slave.lips < 15) ||
		(rule.lipSize == "pretty" && slave.lips < 30) ||
		(rule.lipSize == "plush" && slave.lips < 55) ||
		(rule.lipSize == "huge" && slave.lips < 85) ||
		(rule.lipSize == "facepussy" && slave.lips < 99))	
	{ 
		slave.drugs = "lip injections"; 
		ret = slave.slaveName + "'s lips aren't large enough, so she's been put on lips enhancement.";
		return ret;
	}

	if (slave.drugs != "no drugs")
	{
		slave.drugs = "no drugs";
		ret = slave.slaveName + " has reached growth targets and has been taken off growth injections.";
	}

	return ret;

}

window.growAdvSelectorSlim = function(slave, rule) {

	var ret = "";
	var setd = 0;

	if ((rule.breastSize == "small" && slave.boobs > 350) ||
		(rule.breastSize == "c-cup" && slave.boobs > 550) ||
		(rule.breastSize == "f-cup" && slave.boobs > 1100) ||
		(rule.breastSize == "k-cup" && slave.boobs > 2150) ||
		(rule.breastSize == "p-cup" && slave.boobs > 3700))	
	{ 
		slave.drugs = "breast redistributors"; 
		ret = slave.slaveName + "'s boobs are too big, so she's been put on breast reduction drugs.";
		return ret;
	}
	
	if ((rule.buttSize == "small" && slave.butt > 1) ||
		(rule.buttSize == "plump" && slave.butt > 3) ||
		(rule.buttSize == "huge" && slave.butt > 4) ||
		(rule.buttSize == "enormous" && slave.butt > 6))	
	{ 
		slave.drugs = "butt redistributors"; 
		ret = slave.slaveName + "'s butt is too big, so she's been put on butt reduction drugs.";
		return ret;
	}

	if ((rule.ballSize == "small" && slave.balls > 2) ||
		(rule.ballSize == "big" && slave.balls > 4) ||
		(rule.ballSize == "huge" && slave.balls > 6))	
	{ 
		slave.drugs = "testicle atrophiers"; 
		ret = slave.slaveName + "'s balls are too big, so she's been put on testicle atrophiers.";
		return ret;
	}

	if ((rule.penisSize == "small" && slave.dick > 2) ||
		(rule.penisSize == "big" && slave.dick > 4) ||
		(rule.penisSize == "huge" && slave.dick > 6))	
	{ 
		slave.drugs = "penis atrophiers"; 
		ret = slave.slaveName + "'s dick is too big, so she's been put on penis atrophiers.";
		return ret;
	}

	if ((rule.lipSize == "normal" && slave.lips > 15) ||
		(rule.lipSize == "pretty" && slave.lips > 30) ||
		(rule.lipSize == "plush" && slave.lips > 55) ||
		(rule.lipSize == "huge" && slave.lips > 85))	
	{ 
		slave.drugs = "lip atrophiers"; 
		ret = slave.slaveName + "'s lips are too big, so she's been put on lips atrophiers.";
		return ret;
	}

	if (slave.drugs != "no drugs")
	{
		slave.drugs = "no drugs";
		ret = slave.slaveName + " has reached growth targets and has been taken off growth injections.";
	}

	return ret;
}
*/
